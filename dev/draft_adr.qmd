---
title: "Architecture Decision Record: which type of OO should we use for connector ?"
format: html
editor: visual
---


This documentation will explain why we will use a specific implementation. It is a support for a discution to take the best decicion a the moment with what we know today.

* Understand the need for the connector package
* Investigate the best way of implementing the package
* Give an overview of all posibilities R6, S7 or something else ?

We will give examples only for ADAM dataset and two sources of datasets : File system, Databricks

<!-- Configuration for the quarto doc -->

```{r, include=FALSE}
library(S7)
library(R6)
library(NNaccess) 
library(dplyr) 
```

## Understand the need for the connector package

After years with pDrive and the good pakage NNaccess, NovoNordisk have decided to change the infrastructure of clinical trails. We will use Databricks to store and interact with datasets. 

In this context, we have rethink the NNaccess package to be more genral and be able to use any kind of databases or file system file. The inspiration comes to the DBI package it gives you the possibility this the same package to use different kind of databases. 

The aim is to provide to users the same way of interacting with databases into scripts:

Example just to show the idea :

```{r, eval = FALE}
my_trial <- connector(
    adam = File_system(
        NovoNordisk_way(
            "path_to_trials",
            "csv_files"
        )
    ),
    stdm = File_system(
        NovoNordisk_way(
            "path_to_trials",
            "SAS_files"
        )
    ),
    tfl = File_system(
        NovoNordisk_way(
            "path_to_trials",
            "png_files"
        )
    ),
    ... # Extra possibilites such as metadata and so on
)


con <- connector()

adae <- my_trial %>%
    read_adam("adae")

object_to_save %>%
    write_outputs("tslblcharsumsas.txt", my_trial)

## Extend one function if S7

method(read_adam, list(adam, backend, compagny)) <- function(adam, backend, compagny, ...) {
    con <- backend@con

    write_csv(
        ...
    )
}
```



## Investigate the best way of implementing the package

How it is today into DBI :

DBI is based on S4 and give the opportuity to create a new class to a new database :

```{r, eval=FALSE}
RPostgres::dbWriteTable()


showMethods(RPostgres::dbReadTable)

getMethod(RPostgres::dbReadTable, c("PqConnection", "character"))

```

We would like to mimic this kind of behavior. Our aim is to imitate the DBI package but for a file system and Databricks. 

> Give the opportunity to use differents backend but with the same interface. The API for a user will be the same for all backends.

The inspiration of this comme from the DBI package but also for interfaces in golang. **Set up a structure for differents backend.**

## Try first draft with S3 and S7

#### Testing around the best implementation

Tis part is only here to test some code and see how it works.

We will keep it in this document to have a trace of the work done.


#### First test with S3

Pseudo code for S3 :

```{r, eval = FALSE}

way_to_connect <- "FileSystem"

nn_infra <- list(
    id = "id",
    numtrial = "numtrial",
    root_path = system.file("trials", package = "connector")
)
nn_infra$path_to_trial <- file.path(nn_infra$root_path, paste0(nn_infra$id, "_", nn_infra$numtrial))

adam <- list(
    info_infra = nn_infra,
    path_to_adam = file.path(nn_infra$path_to_trial, "adam")
)

class(adam) <- c("adam_fs_nn", class(adam))


read_adam <- function(x, ...) {
    UseMethod("read_adam", x)
}

read_adam.adam_fs_nn <- function(adam, name) {
    readr::read_csv(
        file.path(
            adam$path_to_adam,
            paste0(name, ".csv")
        )
    )
}

con <- adam

con %>%
    read_adam("adae")


nn_fs <- file_system(
    nn_way()
)

con <- connector(
    adam = nn_fs()
)
``` 

### Working around S7

Try to understand how it works and how we can use it for the connector package.

dispath methods looks like a good idea to implement the connector package.

Example with pseudo code :

```{r, eval = FALSE}

# my_con <- list(
#   connector = list(
#     adam = list(
#       con = "con",
#       read,
#       write,
#       ...
#     )
#   )
# )


### ADAM

## Configuration class
configuration <- new_class(
    "configuration"
)

## Backend class
backend <- new_class(
    "backend"
)

adam <- new_class(
    "adam"
)

read_layer <- new_generic("read_layer", c("adam", "backend", "configuration"))

adam_nn <- adam()
config <- configuration()

basic_backend <- backend()



method(read_layer, list(adam, backend, configuration)) <- function(adam, backend, configuration, ...) {
    message("example of use")
}
# basic use with no modification
read_layer(adam_nn, basic_backend, config)

# Complex use with FS
fs <- new_class(
    parent = backend,
    "fs"
)
fs()

method(read_layer, list(adam, fs, configuration)) <- function(adam, backend, configuration, ...) {
    message("a new method but with fs")
    ok <- list(...)
    message(unlist(ok))
}


method(adam_bk, list(adam, backend)) <- function(adam, backend, ...) {
    message("a new method for adam but with bk")
    
}

read_layer(adam_nn, backend(), config)
read_layer(adam_nn, fs(), config)

read_layer(adam_nn, fs(), config, name = "test")

connector <- function(adam, backend, configuration) {
    adam = adam
    backend = backend
    configuration = configuration

    list(
        adam = adam,
        backend = backend,
        configuration = configuration,
        read_layer = function(...) read_layer(adam, backend, configuration, ...)
    )
}


read_layer_ <- function(connector, ...){
    connector$read_layer(...)
}


con <- connector(adam_nn, fs(), config)

con$read_layer(name = "test")

con |> read_layer_(name = "test")

## Give a list of methods and really looks like a R6 class



## other example

con_default <- connector(adam_nn, backend(), config)

con_default$read_layer()

con_default |> read_layer_()

## databricks example

databricks <- databricks()

my_com <- my_com()


method(read_layer, list(adam, databricks, my_com)) <- function(adam, backend, configuration, ...) {
    message("a new method but with fs")
    
    ok <- list(...)
    message(unlist(ok))
}

con <- connector(adam_nn, databricks(), my_com())
con |> read_layer_(name = "test")

#### First test
## File system class
# file_system <- new_class(
#     parent = backend,
#     "fs",
#     properties = list(
#         configuration = configuration
#     ),
#     constructor = function(configuration) {
#         new_object(
#             S7_object(),
#             configuration = configuration
#         )
#     }
# )

# # A novonordisk configuration for file system
# novo_nordisk <- new_class(
#     parent = configuration,
#     "nn",
#     properties = list(
#         id = class_character,
#         numtrial = class_character,
#         whoami = class_character
#     )
# )

# ## Create a connection
# con <- file_system(
#     novo_nordisk("test", "x", "y")
# )

# info_bc <- new_generic("write", c("backend"))

# method(info_bc, backend) <- function(backend) {
#     message("write")
# }

# info_bc(con)


# ## write adam
# write_adam <- new_generic("write_adam", c("backend", "configuration"))

# method(write_adam, list(backend, configuration)) <- function(backend, configuration) {
#     # complex use
#     backend@configuration
# }

# write_adam(con, novo_nordisk("test", "x", "y"))

# method(write_adam, fs) <- function(fs) {
#     message("write")
# }

# adam <- new_class(
#     "adam",
#     properties = list(
#         backend = backend
#     ),
#     constructor = function(backend) {
#         new_object(
#             S7_object(),
#             backend = backend
#         )
#     }
# )

# adam_nn <- adam(
#     file_system(
#         novo_nordisk("test", "x", "y")
#     )
# )

```



### Examples with FS and S7

Concrete example with FS and S7

```{r}

## Configuration class
configuration <- new_class(
    "configuration"
)

## Backend class
backend <- new_class(
    "backend"
)

layer <- new_class(
    "layer",
    properties = list(
        layer = class_character
    )
)

## Configuration class

novo_nordisk <- new_class(
    parent = configuration,
    "nn",
    properties = list(
        id = class_character,
        numtrial = class_character,
        whoami = class_character,
        ext = class_character,
        name_of_subfolder = class_character
    )
)

# Complex use with FS
fs <- new_class(
    parent = backend,
    "fs",
    properties = list(
      root_path = class_character
    )
)

# our layer

adam <- layer("adam")

construct_path <- new_generic("construct_path", c("fs", "configuration"))

read <- new_generic("read", c("layer", "backend", "configuration"))

write <- new_generic("write", c("layer","backend", "configuration"))

method(construct_path, list(fs, novo_nordisk)) <- function(fs, configuration) {
    file.path(
        fs@root_path,
        paste0(
            configuration@id,
            "_",
            configuration@numtrial
        ),
        configuration@name_of_subfolder
    )
}

construct_path(
   fs(system.file("trials", package = "connector")),
   novo_nordisk("id", "numtrial", "whoami", "csv", "adam")
   )

get_trial_name <- new_generic("get_trial_name", c("configuration"))

method(get_trial_name, novo_nordisk) <- function(configuration) {
    paste0(
        configuration@id,
        "_",
        configuration@numtrial
    )
}

get_trial_name(novo_nordisk("id", "numtrial", "whoami", "csv", "adam"))

method(read, list(layer, fs, novo_nordisk)) <- function(layer, backend, configuration, name) {

  if(configuration@ext == "csv"){
   dataset <- readr::read_csv(
        file.path(
            construct_path(backend, configuration),
            paste0(name, ".", configuration@ext)
        )
    )

    return(dataset)
  }

}

read(   
  layer =  adam, 
  backend = fs(system.file("trials", package = "connector")),
  configuration = novo_nordisk("id", "numtrial", "whoami", "csv", "adam"),
  name = "adae"
)

```

This example give the idea of how we can use S7 to implement the connector package.

### Adding a new way to read with config

How to benefit from dispatching different methods based on the backend and the configuration ?

```{r, eval=FALSE}

default <- new_class(
    parent = configuration,
    "default",
    properties = list(
        id = class_character,
        ext = class_character,
        name_of_subfolder = class_character
    )
)

get_trial_name <- new_generic("get_trial_name", c("configuration"))

method(get_trial_name, default) <- function(configuration) {
    paste0(
        configuration@id
    )
}

my_default_trial <- default("id_numtrial","csv", "adam")

get_trial_name(my_default_trial)

method(construct_path, list(fs, default)) <- function(fs, configuration) {
    file.path(
        fs@root_path,
        paste0(
            configuration@id
        ),
        configuration@name_of_subfolder
    )
}

construct_path(
   fs(system.file("trials", package = "connector")),
   my_default_trial
   )

method(read, list(layer, fs, default)) <- function(layer, backend, configuration, name) {

  if(configuration@ext == "csv"){
   dataset <- readr::read_csv(
        file.path(
            construct_path(backend, configuration),
            paste0(name, ".", configuration@ext)
        )
    )

    return(dataset)
  }

}

read(   
  layer =  adam, 
  backend = fs(system.file("trials", package = "connector")),
  configuration = my_default_trial,
  name = "adae"
)

# my_trial <- connector(
#   adam = list(
#     access = file_system(
#       root_path = system.file("trials", package = "connector")
#     ),
#     configuration = list(
#       name_of_subfolfer = "adam",
#       id = "id",
#       numtrial = "numtrial",
#       ext = "csv"
#     )
#   )
# ) 


```

In conclusion, technicly, using S7 is a possibility but it is not the best way to implement the connector package. 
It is too complex and not really adapted to the need of the package. The configuration class is too linked to the backend class and it is not really flexible. We will not go for a full solution with S7. 

What we have learn : 

- We need a connection class that provide a interface for the user to interact with the data. For example a NovoNordisk filesystem way to acess to the data.
- What could be dispatch for the backend is the way of read, write, list and so on based on the backend and the extension files for a filesystem. In this case a s3 or s7 class could be a good idea.
- Based on the classes, you can exercise very precise control and distribution over the different combinations.

## Example with FS, DBI and R6

#### What about NNaccess first ?

<!-- first draft with R6 -->

```{r, include=FALSE}
## test for implem

# connection <- R6Class(
#     "connection",
#     public = list(
#         conn = NULL,
#         initialize = function(object) {
#             cli::cli_inform("Connection to a backend")
#             self$conn <- object
#         }
#     )
# )


## Overkill for the moment
# fs_nn <- R6Class(
#     "fs_nn",
#     public = list(
#         trial = character(0),
#         project = character(0),
#         instance = character(0),
#         folder = character(0),
#         root = character(0),
#         path_to_trial = character(0),
#         path_to_instance = character(0),
#         initialize = function(trial, project, instance = NULL, root = "~/training") {
#             self$trial <- trial
#             self$project <- project
#             self$instance <- if (is.null(instance)) {
#                 "current"
#             } else {
#                 instance
#             }
#             self$root <- root

#             ## set up trial path and instance path
#             self$path_to_trial <- file.path(self$root, self$project, paste0(self$project, "-", self$trial))
#             cli::cli_alert_info(paste0("The trial path is ", self$path_to_trial))

#             self$path_to_instance <- file.path(self$path_to_trial, self$instance)
#             cli::cli_alert_info(paste0("The instance is ", self$instance))
#         },
#         get_path_trial = function() {
#             cli::cli_alert_info("The trial path is ")
#             self$path_to_trial
#         }
#     )
# )


# init_access <- function(trial, project, instance = NULL, root = "~/training") {
#     invisible(
#         connection$new(
#             fs_nn$new(trial, project, instance, root)
#         )
#     )
# }

# layer_ <- R6Class(
#         "layer",
#         public = list(
#           layer = character(0),
#             connection = NULL,
#             initialize = function(layer, connection) {
#                 self$layer <- layer
#                 self$connection <- connection
#             }
#             )
#     )

# custom_layer <- function(layer, connection, list_of_methods) {

#     custom_layer <- R6Class(
#         "custom_layer",
#         inherit = layer_,
#         public = list_of_methods
#     )

#     custom_layer$new(layer, connection)
# }


# adam <- custom_layer(
#     "adam",
#     init_access("0001", "nn2123"),
#     list(
#         initialize = function(layer, connection) {
#             cli::cli_alert_info("Initialize adam")
#         },
#         read = function(name) {
#             message("read")
#         },
#         write = function(name) {
#             message("write")
#         }
#     )
# )

# adam$connection

# ## Methods

# manipulate_layers <- function(list_of_methods) {
#     R6Class(
#         inherits = layer,
#         "manipulate_layers",
#         public = list(
#             list_of_methods
#         )
#     )
# }
```

#### Implementing a R6 class for file system

The code below is a first draft to implement a R6 class for a file system. We will use the S3 capabilities to dispatch methods based on the backend and the configuration.

```{r}
# Create fake nn trial
# NNtraining::createTrainingDB()

## Test NNaccess

nn <- NNaccess::nnaccess("0001", project = "nn2123", root = "~/training")

# View(nn)

# nn$paths


### Try to keep it simple

builder_fs <- R6Class(
    "fs",
    public = list(
        layer = character(0),
        root_path = character(0),
        initialize = function(layer, root_path) {
            self$layer <- layer
            self$root_path <- root_path
        },
        read = function(...) {
            self |> read(...)
        },
        write = function(...) {
            self |> write(...)
        },
        list_tables = function(...) {
            self |> list_tables(...)
        }
    )
)

create_layer_fs <- function(
    layer, 
    root_path, 
    extra_class = NULL, 
    builder = builder_fs) {

    layer_ <- builder$new(layer, root_path)

    ## Add class for methods
    if(!is.null(extra_class)){
        class(layer_) <- c(paste0(extra_class, "_", class(layer_)[1]), class(layer_))
    }
    
    return(
        layer_
    )
}

```

This is a example of our R6 object for a file system. As you can notice, we have a `read`, `write` and `list_tables` methods. We will use the S3 capabilities to dispatch methods based on the backend and the configuration.

The create layer function give us the opportunity to add a specific class to the layer object. This is a way to add a specific method to a specific layer or a specific *FS* backend.

Because of inheritance, this object have a "fs" class and allow us to define defaults methods for all file system bakcend.

##### Using S3 to dispatch methods

Define defaults methods for the file system backend

```{r}	
read <- function(x, ...) {
    UseMethod("read")
}


write <- function(x, ...) {
    UseMethod("write")
}

list_tables <- function(x, ...) {
    UseMethod("list_tables")
}


## default methods
read.default <- function(x) {
    message("read")
}

write.default <- function(x) {
    message("write")
}

list_tables.default <- function(x) {
    message("list_tables")
}

```

Now goes the really interest of using S3, because of the inheritance, we can define a specific method for our **fs** class.

This example is already a bit complex because our read.fs method is also a generic method that will give us the opportunity to define methos for different kind of files.

```{r}	
## Specific methods

read.fs <- function(x, name,...) {
    message("read adam for my object")
    
    ## Example of dispatch
    find_file <- list.files(x$root_path, full.names = TRUE)[grepl(name, list.files( x$root_path, full.names = TRUE))]
    find_ext <- tools::file_ext(find_file)

    class(find_file) <- c(find_ext, class(find_file))
    read_fs(find_file)
}

read_fs <- function(x, name, ...){
    UseMethod("read_fs")
} 

read_fs.default <- function(x) {
    message("read adam for default files")
    readr::read_csv(x)
}

### Example for parquet files

read_fs.parquet <- function(x) {
    message("read adam for default parquet files")
}

## or readRDS

read_fs.rds <- function(x) {
    message("read adam for default rds files")
    readr::read_rds(x)
}

```

Our methods are now defined and we can use them with our object.

#### Concrete example 

```{r}

adam <- create_layer_fs("adam", 
system.file("trials", "id_numtrial", "adam", package = "connector")
)

### Example for xlsx
# adam_xlsx <- create_layer_fs("adam", system.file("trials", "id_numtrial", "adam", package = "connector"), extra_class = "xlsx")


adam |> read(name = "adae")


fs <- create_layer_fs
```


#### And with a pseudo configuration

```{r}
connector_test <- function(config) {
    root_path_to_tral <- file.path(config$root_path, paste0(config$trial, "_", config$project))

    ## Create a layers
    layers <- purrr::imap(
        config$layers,
        function(x, y) {
            x(y, file.path(root_path_to_tral, y))
        }
    )

    return(
        layers
    )
}

config <- list(
    trial = "id",
    project = "numtrial",
    root_path = system.file("trials", package = "connector"),
    layers = list(
        adam = fs,
        stdm = fs,
        output = fs
    )
)

con <- connector_test(config)

con$adam$read(name = "adae")

con$output$write()

# read <- function(x, layer, name) {
#   x[[layer]] |> read(name)
# }

# con |> read("adam", "adae")

# con |> read("whatever", "adae")

# con |> adam$read("adae")

```

### Example with a DBI connection

We can define a new backend for a DBI connection.

```{r}
 
### DBI backend

builder_dbi <- R6Class(
    "dbi",
    public = list(
        layer = character(0),
        conn = NULL,
        initialize = function(layer, conn) {
            self$layer <- layer
            self$conn <- conn
        },
        read = function(...) {
            self |> read(...)
        },
        write = function(...) {
            self |> write(...)
        },
        list_tables = function(...) {
            self |> list_tables(...)
        },
        get_conn = function() {
            self$conn
        },
        close = function() {
            DBI::dbDisconnect(self$conn)
        }
    )
)

create_layer_dbi <- function(layer, conn, extra_class = NULL) {
    layer_ <- builder_dbi$new(layer, conn)

    ## Add class for methods
    if(!is.null(extra_class)){
        class(layer_) <- c(paste0(extra_class, "_", class(layer_)[1]), class(layer_))
    }

    return(
        layer_
    )
}

## small tools

connection_or_not <- function(x) {
    tryCatch({
        DBI::dbIsValid(x)
    }, error = function(e) {
        stop("The connection is not valid")
    })
}


read.dbi <- function(x, name) {
    message("read adam for DBI object")
    
    connection_or_not(x$get_conn())

    x$get_conn() |> DBI::dbReadTable(name)
}

write.dbi <- function(x, name, value) {
    message("write adam for DBI object")

    connection_or_not(x$get_conn())

    x$get_conn() |> DBI::dbWriteTable(name, value)
}

list_tables.dbi <- function(x) {
    message("list_tables for DBI object")

    connection_or_not(x$get_conn())

    x$get_conn() |> DBI::dbListTables()
}

adam_dbi <- create_layer_dbi("adam", DBI::dbConnect(RSQLite::SQLite(), ":memory:"))

adam_dbi$write("mtcars", mtcars)

adam_dbi$read("mtcars")


```

This concrete example show how we can use the same interface for different backend. We have a file system backend and a DBI backend. We can use the same methods for both backend.

So scripts will be the same for a user, only the configuration will change.

##### Example with a extra class

What happen if a compagny want to add a specific method for a specific backend or a specific layer ?

> They can use the extra class to modify a specific method for a specific backend.

For now, we have define extra class to be design such as : 

**extra class + previous class**

For a DBI example :

If you want a extra class for a compagny, you will use a the extra class param :

**extra_class = "my_company"**

And you will have a specific class for your compagny for the DBI backend : **my_company_dbi**


If it was for fs, you will have : **my_company_fs**

Here a concrete example :

```{r}

### Because of the inherit class
stdm_dbi_extra_class <- create_layer_dbi(
    "stdm",
     DBI::dbConnect(RSQLite::SQLite(), ":memory:"),
      "my_com"
      )

stdm_dbi_extra_class$write("mtcars", mtcars)
stdm_dbi_extra_class$read("mtcars") 

class(stdm_dbi_extra_class)

### But it is to overwrite by define a method

list_tables.my_com_dbi <- function(x) {
    message("a my_com method for list_tables")
    
    connection_or_not(x$get_conn())

    tables <- x$get_conn() |> DBI::dbListTables()

    lapply(tables, function(x) {
        cli::cli_alert_success( paste0("name of the table ", x))
    })

    invisible(tables)
}

tables <- stdm_dbi_extra_class$list_tables()

tables

### About a speficic method for a specific layer
#### The simplest way to do that is to add a id to the extra class

my_specific_stdm <- create_layer_dbi("stdm", DBI::dbConnect(RSQLite::SQLite(), ":memory:"), "spec_stdm")

class(my_specific_stdm)

list_tables.spec_stdm_dbi <- function(x) {
    cli::cli_alert_warning("It is only for my_specific_stdm")
    message("list_tables for DBI object")
}

my_specific_stdm$list_tables()

```


### A example with a yaml configuration

This example is here to illustrate how we can use a yaml configuration to define the backend and the configuration for a specific compagny.

Read the yaml file
```{r}
yaml_config <- yaml::read_yaml(system.file("config", "default_config.yaml", package = "connector"))
yaml_config
```


Based on the information in the yaml file, we can create a connection object.

```{r}
create_connection <- function(yaml_config) {
    ## logic for our trial

    my_trial <- yaml_config[[1]]$study

    ## logic for our backend, default or not ?

    backends_config <- purrr::map(yaml_config[[1]]$layers, "conn")

    not_a_list <- purrr::negate(is.list)
    default_or_not <- purrr::map_lgl(backends_config, not_a_list)

    # TODO : make it customizable

    ## Only define for the default backend
    backends <- purrr::imap(
        yaml_config[[1]]$layers,
        function(x, y) {
            get_backend <- x[["conn"]]

            if (x[["conn"]] == "fs") { # bad way of doing this

                ## logic for a my_trial, have to be customize
                my_trial <- yaml_config[[1]]$study
                trial_folder <- paste0(my_trial["project"], "-", my_trial["trial"])
                path_to_trial <- file.path(my_trial$project, trial_folder, my_trial$instance)

                ## have to be customize as well
                path_to_data <- file.path(yaml_config[[1]][[get_backend]][["root_path"]],path_to_trial, "stats", "data", y)


                get(
                    paste0("create_layer_", get_backend)
                )(
                    y,
                    path_to_data
                )
            } else if (x[["conn"]] == "dbi") {

                get(
                    paste0("create_layer_", get_backend)
                )(
                    y,
                    DBI::dbConnect(RSQLite::SQLite(), yaml_config[[1]][[x[["conn"]]]]$path_to_file)
                )
            }
        }
    )


    return(
        backends
    )
} 

con <- create_connection(yaml_config)

con$adam$read("adae")

con$stdm$write("mtcars", mtcars)
con$stdm$read("mtcars")

```

This small example show, based on a yaml file, how we can create a connection object.

### Add a specific method for a backend

How to add a new method for an exiting backend ? 

For example, inside our **fs** backend, we would like to add a new method to get information on one file.

To proceed, we have three possibilities :

- Add a new method to **a copy** of the ***fs*** object generator itself, but you will have to use this instanciation and not *builder_fs*.
- Create a specific object and play with, make it harder for the user to use it.
- Add a new method to the ***fs*** object generator itself, but it will be available for all **fs** backend for the package used.

1. First option is the best way (in my opinion): 

```{r}
## copy the builder
new_fs <- R6Class(
    "new_fs",
    inherit = builder_fs
)


## Add a new method

new_fs$set("public","get_info", function(name) {
    message("get info for a file")
    file.info(file.path(self$root_path, name))
})

## Create a new layer

adam_new <- create_layer_fs("adam", system.file("trials", "id_numtrial", "adam", package = "connector"), builder = new_fs)

adam_new$get_info("adae.csv")

adam_new$read("adae")

```	

So as a developer, you just have to create a new builder with the previous builder as parent and add a new method to it. 
Everything related to the ***fs*** backend still works. But you can customize your own standard methods for reading, writing, and so on.

Example : 

```{r}
read.new_fs <- function(x, name) {
    cli::cli_alert("read for new_fs")
}

adam_new$read("adae")
```

This is a simple example.

2. Second option is to create a new object and play with it.

```{r}
## Create a new object
adam_second <- create_layer_fs("adam", system.file("trials", "id_numtrial", "adam", package = "connector"))

adam_second$get_info("adae.csv")

adam_second$set("public","get_info", function(name) {
    cli::cli_alert("get info for a file")
    file.info(
        file.path(self$root_path, name)
        )
})

```

### What about a different configuration for a other compagny ?


```{r}

```
